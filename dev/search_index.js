var documenterSearchIndex = {"docs":
[{"location":"guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"SpectralWaves.jl is a Julia package for simulation of nonlinear waves propagating over arbitrary topography.","category":"page"},{"location":"guide/#Instalation","page":"Guide","title":"Instalation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"pkg> add SpectralWaves\njulia> using SpectralWaves","category":"page"},{"location":"guide/#Quick-start","page":"Guide","title":"Quick start","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"We begin our introduction with application of the model to linear and regular waves of length L and height H propagating in water of constant depth d. We consider one wave along the length of the domain ell. ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using SpectralWaves\nusing CairoMakie # plotting package\n\nd = 1.0 # water depth (m)\nH = 0.1 # wave height (m)\nL = 2.0 # wavelength (m)\n‚Ñì = L # fluid domain length (m) - one wave\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We define a number of numerical model parameters.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"M_s = 0 # FSBC Taylor series order (linear wave)\nM_b = 0 # BBC Taylor series order (horizontal bottom)\n‚Ñê = 1 # number of harmonics\nnŒît = 200 # number of time increments per wave period\nnT = 1 # number of periods\nN = nŒît * nT # number of time steps\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We initialize wave problem using init_problem function.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Œ∫, Œ∑ÃÇ, Œ∑Ãá, Œ≤ÃÇ, Œ≤Ãá, œïÃÇ, œïÃá, œàÃÇ, œàÃá, pÃÇ, œá, Œæ, Œ∂, ùíØ, ùíÆ, O = init_problem(‚Ñì, d, ‚Ñê, N)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Initial condition values of hateta, doteta, hatphi, and dotphi are computed and inserted into vectors Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá using linear_regular_wave! in-place function, which additionally returns values of a wave period T and a time increment Delta t.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"T, Œît = linear_regular_wave!(Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá, H, L, d, ‚Ñê, nŒît, O)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now, we are ready to solve a problem. We use an in-place function solve_problem! which stores the values of solution coefficients in vectors Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá, œàÃÇ, œàÃá. In our case only Œ∑ÃÇ will be further processed.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"solve_problem!(Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá, œàÃÇ, œàÃá, Œ≤ÃÇ, Œ≤Ãá, pÃÇ, Œ∫, ùíØ, ùíÆ, ‚Ñê, M_s, M_b, Œît, O, N, œá, Œæ, Œ∂, ‚Ñì, d)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Finally we are ready to plot evolution of absolute, real and imaginary values of a complex wave amplitude Œ∑ÃÇ over time t corresponding to one wave period.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"t = range(start = 0, stop = N*Œît, step = Œît) # time vector\nset_theme!(theme_latexfonts()) # use latex fonts\nupdate_theme!(fontsize=10)\nfig = Figure(size = (400, 300))\nax = Axis(fig[1, 1], xlabel = L\"t/T\", ylabel = L\"4\\hat{\\eta}/H\", xticks = 0:0.1:N, yticks = -1:0.5:1)\nlines!(ax, t / T, 4 * abs.(Œ∑ÃÇ[1, O:end]) / H, label = L\"|\\hat{\\eta}|\")\nlines!(ax, t / T, 4 * real.(Œ∑ÃÇ[1, O:end]) / H, label = L\"Re(\\hat{\\eta})\")\nlines!(ax, t / T, 4 * imag.(Œ∑ÃÇ[1, O:end]) / H, label = L\"Im(\\hat{\\eta})\")\naxislegend(ax, position = :lb)\nfig","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Now, if we want to plot a time-series of free-surface elevation at some location (e.g. corresponding to the middle of the fluid domain x_0 = ell2) eta(tn x_0), we use an inverse_fourier_transform function, like so","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"x_0 = ‚Ñì/2\nŒ∑(n) = inverse_fourier_transform(Œ∑ÃÇ[:, n], Œ∫, x_0)\nfig = Figure(size = (400, 300))\nax = Axis(fig[1, 1], xlabel = L\"$t$ (s)\", ylabel = L\"$\\eta$ (m)\")\nlines!(ax, t, Œ∑.(O:N+O), color = :blue, linewidth = 2)\nlimits!(ax, 0, T, -H, H)\nfig","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Œ∑(O), Œ∑(N+O), t","category":"page"},{"location":"api/#API","page":"API reference","title":"API","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = SpectralWaves","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [SpectralWaves]","category":"page"},{"location":"api/#SpectralWaves.absolute_error-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"API reference","title":"SpectralWaves.absolute_error","text":"absolute_error(a::Vector{<:Number}, b::Vector{<:Number})\n\nCompute absolute error between vectors a and b.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 1]; absolute_error(a, b)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.convolution_power-Tuple{Vector{<:Number}, Integer}","page":"API reference","title":"SpectralWaves.convolution_power","text":"convolution_power(a::Vector{<:Number}, n::Integer)\n\nCompute convolution n-th power of vector a.\n\nExamples\n\njulia> a = [1, 2, 3]; convolution_power(a, 3)\n7-element Vector{Int64}:\n  1\n  6\n 21\n 44\n 63\n 54\n 27\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.convolution_range-Tuple{Integer, Integer, Integer}","page":"API reference","title":"SpectralWaves.convolution_range","text":"convolution_range(m::Integral, M::Integral, n::Integer)\n\nCompute range r of indices of a central part of convolution vector corresponding to the m-th order of convolution, where M is the maximum order of convolution, N is the length of convolution vector corresponding to the M-th order of convolution, and ‚Ñê is the number of harmonics.\n\nExamples\n\njulia> m = 1; M = 3; ‚Ñê = 5; c_range = convolution_range(m, M, ‚Ñê)\n11:31\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.convolve-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Vector{Ta}, Vector{Tb}}} where {Ta<:Number, Tb<:Number}","page":"API reference","title":"SpectralWaves.convolve","text":"convolve(a::Vector{Ta}, b::Vector{Tb}) where {Ta<:Number, Tb<:Number}\n\nCompute direct convolution of vectors a and b.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 1]; convolve(a, b)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.factorial_lookup-Tuple{Integer}","page":"API reference","title":"SpectralWaves.factorial_lookup","text":"factorial_lookup(n::Integer)\n\nCompute lookup table for factorials of numbers from 0 to n.\n\nExamples\n\njulia> factorial_lookup(3)\n4-element Vector{Float64}:\n  1.0\n  1.0\n  2.0\n  6.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.fourier_transform-Tuple{Vector{<:Real}, Number, AbstractRange{<:Number}}","page":"API reference","title":"SpectralWaves.fourier_transform","text":"fourier_transform(f::Vector{<:Number}, œâ::Number, x::AbstractRange{<:Number})\n\nCompute fÃÇ(œâ) using function values f at points x.\n\nExamples\n\njulia> f = [-1, 0, 1, 0, -1]; œâ = 1; x = range(-œÄ, œÄ, length = 5);\njulia> fourier_transform(f, œâ, x)\n0.5 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.general_error-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"API reference","title":"SpectralWaves.general_error","text":"general_error(a::Vector{<:Number}, b::Vector{<:Number})\n\nCompute a general error between vectors a and b as a relative_error(a, b) or an absolute_error(a, b) for norm(a) not equal or equal to 0, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.init_nonlinear_bottom_boundary_condition-NTuple{5, Any}","page":"API reference","title":"SpectralWaves.init_nonlinear_bottom_boundary_condition","text":"init_nonlinear_bottom_boundary_condition(Œ∫, ùíØ, ùíÆ, ‚Ñê, M)\n\nInitialize expansion coefficients for nonlinear bottom boundary conditions for eigenvalues Œ∫, hyperbolic tangent ùíØ and secant ùíÆ values, number of harmonics ‚Ñê and order of nonlinear expansion M.\n\nOutput is a tuple (Œ®ÃÇ‚Ä≤, Œ®ÃÇ‚Ä≥, Œ®ÃÉ‚Ä≤, Œ®ÃÉ‚Ä≥), where:\n\nŒ®ÃÇ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ®ÃÇ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing bottom velocity potential amplitudes and its vertical gradients,\nŒ®ÃÉ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ®ÃÉ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing bottom horizontal velocity potential amplitudes and its vertical gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.init_nonlinear_surface_boundary_condition-NTuple{5, Any}","page":"API reference","title":"SpectralWaves.init_nonlinear_surface_boundary_condition","text":"init_nonlinear_surface_boundary_condition(Œ∫, ùíØ, ùíÆ, ‚Ñê, M)\n\nInitialize expansion coefficients for nonlinear free-surface boundary conditions for eigenvalues Œ∫, hyperbolic tangent ùíØ and secant ùíÆ values, number of harmonics ‚Ñê and order of nonlinear expansion M.\n\nOutput is a tuple (Œ¶Ãá‚Ä≤, Œ¶Ãá‚Ä≥, Œ¶ÃÇ‚Ä≤, Œ¶ÃÇ‚Ä≥, Œ¶ÃÉ‚Ä≤, Œ¶ÃÉ‚Ä≥), where:\n\nŒ¶Ãá‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ¶Ãá‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing\n\nsurface acceleration potential amplitudes and its vertical gradients,\n\nŒ¶ÃÇ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ¶ÃÇ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing\n\nsurface velocity potential amplitudes and its vertical gradients,\n\nŒ¶ÃÉ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ¶ÃÉ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing\n\nsurface horizontal velocity potential amplitudes and its vertical gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.init_problem-Tuple{Number, Number, Integer, Integer}","page":"API reference","title":"SpectralWaves.init_problem","text":"init_problem(‚Ñì::Number, d::Number, ‚Ñê::Integer, N::Integer; O = 4)\n\nInitialize IBVP wave problem corresponding to a fluid domain of length ‚Ñì and depth d with ‚Ñê harmonics and N time steps.\n\nOutput is a tuple (Œ∑ÃÇ, Œ∑Ãá, Œ≤ÃÇ, Œ≤ÃÉ, Œ≤Ãá, œïÃÇ, œïÃá, œàÃÇ, œàÃá, pÃÇ, œá, Œæ, Œ∂, ùíØ, ùíÆ, O), where:\n\nŒ∑ÃÇ are free-surface elevation amplitudes (m),\nŒ∑Ãá are free-surface vertical velocity amplitudes (m/s),\nŒ≤ÃÇ are bottom-surface elevation amplitudes (m),\nŒ≤Ãá are bottom-surface vertical velocity amplitudes (m/s),\nœïÃÇ are flat-bottom velocity potential amplitudes (m¬≤/s),\nœïÃá are flat-bottom acceleration potential amplitudes (m¬≤/s¬≤),\nœàÃÇ are uneven-bottom velocity potential amplitudes (m¬≤/s),\nœàÃá are uneven-bottom acceleration potential amplitudes (m¬≤/s¬≤),\npÃÇ are surface pressure head amplitudes (m),\nœá is wavemaker paddle displacement (m),\nŒæ is wavemaker paddle velocity (m/s),\nŒ∂ is wavemaker paddle acceleration (m/s¬≤),\nùíØ are hyperbolic tangent lookup values,\nùíÆ are hyperbolic secant lookup values,\nO is the order of the time-stepping scheme.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.inverse_fourier_transform-Tuple{Vector{<:Number}, AbstractRange{<:Number}, Number}","page":"API reference","title":"SpectralWaves.inverse_fourier_transform","text":"inverse_fourier_transform(fÃÇ::Vector{<:Number}, œâ::AbstractRange{<:Number}, x::Number)\n\nCompute f(x) using expansion amplitudes fÃÇ and eigenvalues œâ.\n\nExamples\n\njulia> fÃÇ = [0.5, 0, 0.5]; œâ = -1:1; x = œÄ; inverse_fourier_transform(fÃÇ, œâ, x)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.nonlinear_dfsbc_correction-NTuple{19, Any}","page":"API reference","title":"SpectralWaves.nonlinear_dfsbc_correction","text":"nonlinear_dfsbc_correction(Œ∑ÃÇ, œïÃÇ, œïÃá, œàÃÇ, œàÃá, Œ¶Ãá‚Ä≤, Œ¶Ãá‚Ä≥, Œ¶ÃÇ‚Ä≤, Œ¶ÃÇ‚Ä≥, Œ¶ÃÉ‚Ä≤, Œ¶ÃÉ‚Ä≥, Œ∫‚Ä≤, ‚Ñê, F, M, Œæ, Œ∂, ‚Ñì, d)\n\nCalculate nonlinear correction Œ¥œïÃá to dynamic free-surface boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.nonlinear_kfsbc_correction-NTuple{14, Any}","page":"API reference","title":"SpectralWaves.nonlinear_kfsbc_correction","text":"nonlinear_kfsbc_correction(Œ∑ÃÇ, œïÃÇ, œàÃÇ, Œ¶ÃÇ‚Ä≤, Œ¶ÃÇ‚Ä≥, Œ¶ÃÉ‚Ä≤, Œ¶ÃÉ‚Ä≥, Œ∫, Œ∫‚Ä≤, ‚Ñê, F, M)\n\nCalculate nonlinear correction Œ¥Œ∑Ãá to kinematic free-surface boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.relative_error-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"API reference","title":"SpectralWaves.relative_error","text":"relative_error(a::Vector{<:Number}, b::Vector{<:Number})\n\nCompute relative error between vectors a and b.\n\nExamples\n\njulia> a = [2, 2]; b = [1, 1]; relative_error(a, b)\n0.5\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.solve_problem!-NTuple{23, Any}","page":"API reference","title":"SpectralWaves.solve_problem!","text":"solve_problem!(Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá, œàÃÇ, œàÃá, Œ≤ÃÇ, Œ≤Ãá, pÃÇ, Œ∫, ùíØ, ùíÆ, ‚Ñê, M_s, M_b, Œît, O, N, œá, Œæ, Œ∂, ‚Ñì, d; static_bottom=true)\n\nCalculate solution coefficients Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá, œàÃÇ, œàÃá of the wave problem.\n\nModified in-place variables:\n\nŒ∑ÃÇ are free-surface elevation potential amplitudes (m),\nŒ∑Ãá are free-surface vertical velocity amplitudes (m/s),\nœïÃÇ are flat-bottom velocity potential amplitudes (m¬≤/s),\nœïÃá are flat-bottom acceleration potential amplitudes (m¬≤/s¬≤),\nœàÃÇ are uneven-bottom velocity potential amplitudes (m¬≤/s),\nœàÃá are uneven-bottom acceleration potential amplitudes (m¬≤/s¬≤),\n\nInput variables:\n\nŒ≤ÃÇ are bottom-surface elevation amplitudes (m),\nŒ≤Ãá are bottom-surface vertical velocity amplitudes (m/s),\npÃÇ are surface pressure head amplitudes (m),\nŒ∫ are wave numbers (rad/m),\nùíØ are hyperbolic tangent lookup values,\nùíÆ are hyperbolic secant lookup values,\n‚Ñê is the number of harmonics,\nM_s is the order of nonlinear free-surface boundary condition,\nM_b is the order of nonlinear bottom boundary condition,\nŒît is the time step (s),\nO is the order of the time-stepping scheme,\nN is the number of time steps,\nœá is wavemaker paddle displacement (m),\nŒæ is wavemaker paddle velocity (m/s),\nŒ∂ is wavemaker paddle acceleration (m/s¬≤),\n‚Ñì is the fluid domain length (m),\nd is the water depth (m).\n\nKeyword arguments:\n\nstatic_bottom is a boolean flag to indicate whether the bottom is static.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.time_integration_coeffs-Tuple{Integer}","page":"API reference","title":"SpectralWaves.time_integration_coeffs","text":"time_integration_coeffs(O::Integer)\n\nCalculate Adams-Bashforth-Moulton time-stepping scheme coefficients for a given order O.\n\nOutput is a tuple of two vectors with Adams-Bashforth and Adams-Moulton coefficients, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.toeplitz-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"API reference","title":"SpectralWaves.toeplitz","text":"toeplitz(a::Vector{T}) where T\n\nTransform vector a to a Toeplitz matrix.\n\nExamples\n\njulia> a = [1, 2, 3]; toeplitz(a)\n2√ó2 Matrix{Int64}:\n 2  1\n 3  2\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.update_bbc_sle!-NTuple{13, Any}","page":"API reference","title":"SpectralWaves.update_bbc_sle!","text":"update_bbc_sle!(A‚Ä≤, A‚Ä≥, Œ®ÃÇ‚Ä≤, Œ®ÃÇ‚Ä≥, Œ®ÃÉ‚Ä≤, Œ®ÃÉ‚Ä≥, w‚Ä≤, Œ≤ÃÇ, Œ∫, Œ∫‚Ä≤, ‚Ñê, F, M)\n\nCompute coefficients A‚Ä≤, A‚Ä≥, and w‚Ä≤ for the bottom boundary condition system of linear equations (SLE).\n\nModified in-place variables:\n\nA‚Ä≤ are constant coefficients of the system of linear equations and\nA‚Ä≥ are coefficients of the system of linear equations,\nw‚Ä≤ are coefficients corresponding to the linear wavemaker term.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpectralWaves","category":"page"},{"location":"#SpectralWaves.jl","page":"Home","title":"SpectralWaves.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Fourier Galerkin method solution to nonlinear waves propagating over topography.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpectralWaves.jl is a Julia package for simulation of nonlinear waves propagating over arbitrary topography under potential flow assumptions. The solution is derived using a Fourier Galerkin spectral method in terms of amplitudes of free-surface elevation and velocity potential, while inverse Fourier transform is used to get a phase-resolved wave field. Four wave generation mechanisms are supported - initial conditions, linear wavemaker forcing, pressure forcing (to be implemented), moving bottom. ","category":"page"},{"location":"#Wave-problem","page":"Home","title":"Wave problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We consider waves propagating over arbitrary bottom topography in a periodic fluid domain of length ell and characteristic depth d (corresponding to still water level). A Cartesian coordinate system is used to define fluid elements along horizontal x-axis coinciding with undisturbed free surface and upward-pointing and vertical z-axis. Undulating free surface is described by means of eta(x t), while bottom topography is considered as fluctuations beta(x t) around -d. The general scheme is presented in figure 1 below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"../../examples/docs_figure_1.jl\") # hide\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 1: Propagation of waves over topography in a periodic fluid domain.","category":"page"},{"location":"","page":"Home","title":"Home","text":"According to potential flow assumptions (irrotational flow of an inviscid and incompressible fluid), we define velocity vector field mathbfv(x z t) = nablaPhi(x z t) and formulate a our boundary-value problem in a following way (table 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Table 1: Initial boundary-value problem of waves propagating over topography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equation Region Description\nfracpartial^2Phipartial x^2 + fracpartial^2Phipartial z^2 = 0 -d + beta leq z leq eta Laplace's equation\nfracpartialetapartial t + fracpartialetapartial xfracpartialPhipartial x - fracpartialPhipartial z = 0 z = eta Kinematic free-surface boundary condition\nfracpartialPhipartial t + geta + frac12left(u^2 + w^2 right) = 0 z = eta Dynamic free-surface boundary condition\nfracpartialbetapartial t + fracpartialbetapartial xfracpartialPhipartial x - fracpartialPhipartial z = 0 z = beta - d Kinematic bottom boundary condition\nPhi(x + ell z t) = Phi(x z t) x = 0 ell Periodic lateral boundary condition","category":"page"},{"location":"","page":"Home","title":"Home","text":"where u = partialPhi  partial x and w  = partialPhi  partial z are horizontal and vertical velocity components, respectively, while a gravitational acceleration gapprox 981mathrmms^2. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below, we provide a description of the spectral solution to the problem of waves propagating over topography. Anxious users may skip this part and go directly to our guide.","category":"page"},{"location":"#Spectral-solution","page":"Home","title":"Spectral solution","text":"","category":"section"},{"location":"#Fourier-series-expansions","page":"Home","title":"Fourier series expansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We use spectral expansions of Phi, eta, and beta, while additionally Phi is decomposed into parts: phi - satisfying homogeneous problem of waves propagating over horizontal bottom and psi - satisfying a corrugated bottom correction. The total velocity potential Phi satisfies Laplace equation. In Table 2, we provide spectral expansion formulas of Phi, phi, psi, eta, and beta along with velocity components u and w.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Table 2: Spectral expansion formulas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equation Description\nPhi(x z t) = phi(x z t) + psi(x z t) Total velocity potential\nphi(x z t) = sum_i=-I^I hatphi_i(t)fraccoshkappa_i(z+d)coshkappa_idmathrme^mathrmikappa_ix Flat-bottom velocity potential\npsi(xzt) = hatpsi_0(t)z + sum_i=-Iwedgeine0^Ihatpsi_i(t)fracsinhkappa_izkappa_icoshkappa_idmathrme^mathrmikappa_ix Corrugated bottom velocity potential\neta(x t) = sum_i=-I^Ihateta_i(t)mathrme^mathrmikappa_ix Free-surface elevation\nbeta(x t) = sum_i=-I^Ihatbeta_i(t)mathrme^mathrmikappa_ix Bottom topography\nu(x z t) = sum_i=-Iwedgeine0^Imathrmifrachatphi_i(t)kappa_icoshkappa_i(z+d) + hatpsi_i(t)sinhkappa_izcoshkappa_idmathrme^mathrmikappa_ix Horizontal velocity component\nw(x z t) = hatpsi_0(t)+ sum_i=-Iwedgeine0^Ifrachatphi_i(t)kappa_isinhkappa_i(z+d) + hatpsi_i(t)coshkappa_izcoshkappa_idmathrme^mathrmikappa_ix Vertical velocity component","category":"page"},{"location":"","page":"Home","title":"Home","text":"where kappa_i=i2piell are solution eigenvalues corresponding to I individual wave harmonics; the primed sum refers to omitting non-oscillatory eigenvalue kappa_0=0. mathrmi^2=-1, while the hat accent hat denotes solution amplitudes. We also use tilde tilde and dot dot accents to highlight amplitudes corresponding to time and horizontal gradients.","category":"page"},{"location":"#Taylor-series-expansions","page":"Home","title":"Taylor series expansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The solution to the wave problem is achieved by introducing Fourier series expansions presented in table 2 to Taylor series expansions of boundary conditions presented in table 1. As a result, we get two evolution equations of free-surface elevation and velocity potential (from the kinematic and dynamic free-surface boundary conditions) and a set of linear equations (SLE) relating velocity potential coefficients of a homogeneous flat-bottom and corrugated problem (from the bottom boundary condition). In table 3, we provide implementation-ready forms of the solution equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Table 3: Implementation-ready forms of the solution equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equation Description\ndoteta_i = kappa_ihatphi_imathcalT_i + hatpsi_imathcalS - deltadoteta_i Evolution equation for free-surface elevation\ndotphi_i = -ghateta_i - deltadotphi_i Evolution equation for velocity potential\nleft(mathbfI-sum_m=0^M_psi-1left(mathbftildeB_modotleft(mathbftildePsi_m^primeotimesmathbf1right)-mathbfhatB_modotleft(mathbfhatPsi_m+1^primeotimesmathbf1right)right)right)cdotmathbfhatpsi=mathbfdotbeta + sum_m=0^M_psi-1left(mathbftildeB_modotleft(mathbftildePsi_m^primeprimeotimesmathbf1right)-mathbfhatB_modotleft(mathbfhatPsi_m+1^primeprimeotimesmathbf1right)right)cdotmathbfhatphi System of linear equations relating bottom and flat-bed velocity potential coefficients","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":" \nmathcalT_i = tanhkappa_id\nmathcalS_i = mathrmsechkappa_id\ndeltadoteta_i = sum_m=0^M_phi-1left(fracmathbfhateta^*mm*left(mathbftildeeta*mathbftildePhi_m-frac1m+1mathbfhateta*mathbfhatPhi_m+1right)right)_i\ndeltadotphi_i = sum_m=0^M_phi-1left(fracmathbfhateta^*mm*left(frac1m+1mathbfhateta*mathbfdotPhi_m+1+frac12sum_n=0^mbinommnleft(mathbftildePhi_n*mathbftildePhi_m-n+mathbfhatPhi_n*mathbfhatPhi_m-nright)right)right)_i\ntildeeta_i = mathrmikappa_ihateta\ndotPhi_im = kappa_i^mdotphi_i(2mid m) + (kappa_i^mdotphi_imathcalT_i + kappa_i^m-1dotpsi_imathcalS_i)(2nmid m)\nhatPhi_im = (kappa_i^m+1hatphi_imathcalT_i + kappa_i^mhatpsi_imathcalS_i)(2mid m) + kappa_i^m+1hatphi_i(2nmid m)\ntildePhi_im = mathrmikappa_i^m+1hatphi_i(2mid m) + mathrmi(kappa_i^m+1hatphi_imathcalT_i + kappa_i^mhatpsi_imathcalS_i)(2nmid m)\nhatPsi_i = kappa_i^mhatpsi_i(2mid m) + (kappa_i^m+1hatphi_imathcalS_i - kappa_i^mhatpsi_imathcalT_i)(2nmid m)\ntildePsi_i = mathrmi(kappa_i^m+1hatphi_imathcalS_i - kappa_i^mhatpsi_imathcalT_i)(2mid m) + mathrmikappa_i^mhatpsi_i(2nmid m)\nmathbftildeB_ijm = left(fracmathbfhatbeta^*m*mathbftildebetamright)_i-j\nmathbfhatB_ijm = left(fracmathbfhatbeta^*(m+1)(m+1)right)_i-j\nhatPsi_im^prime = kappa_i^m(2mid m) - kappa_i^mmathcalT_i(2nmid m)\nhatPsi_im^primeprime = kappa_i^m+1mathcalS_i(2nmid m)\ntildePsi_im^prime = - mathrmikappa_i^mmathcalT_i(2mid m) + mathrmikappa_i^m(2nmid m)\ntildePsi_im^prime = mathrmikappa_i^m+1mathcalS_i(2mid m)","category":"page"},{"location":"#Numerics","page":"Home","title":"Numerics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provided that initial conditions with respect to mathbfhatphi, mathbfdotphi, mathbfhatpsi, mathbfdotpsi, mathbfhateta, mathbfdoteta are known and the bottom and its evolution is prescribed in terms of mathbfhatbeta and mathbfdotbeta, respectively, we apply time-stepping procedure to get the solution. It is based on iterative application of evolution equations and solving the system of linear equations at each time step until a desired accuracy is reached. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Adams-Bashforth-Moulton time-stepping method is chosen and is used according to Last Point Approximation scheme, where the predictor is applied to the velocity potential amplitudes and the corrector to the free-surface elevation amplitudes. Below the simplest formulas of mathcalO(1) are provided","category":"page"},{"location":"","page":"Home","title":"Home","text":" \nhatphi_i(t+Delta t) = hatphi_i(t) + Delta tdotphi_i(t) AB predictor mathcalO(1)\nhateta_i(t+Delta t) = hateta_i(t) + Delta tdoteta_i(t + Delta t) AM corrector mathcalO(1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In between predictor and corrector evaluations and at each iteration, a system of linear equations matching hatphi_i and hatpsi_i coefficients is solved. In case of static bottom topography, an initial factorization of SLE coefficients matrix is employed for efficiency.","category":"page"}]
}
