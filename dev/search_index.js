var documenterSearchIndex = {"docs":
[{"location":"guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"SpectralWaves.jl is a Julia package for simulation of nonlinear waves propagating over arbitrary topography.","category":"page"},{"location":"guide/#Instalation","page":"Guide","title":"Instalation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"pkg> add SpectralWaves\njulia> using SpectralWaves","category":"page"},{"location":"guide/#Quick-start","page":"Guide","title":"Quick start","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"We begin our introduction with an evolution of a free surface for an initial bump of water in a domain of length ‚Ñì and still water depth d. We aim to compare free-surface evolution for the case of constant and uneven bottom.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using SpectralWaves\nusing CairoMakie # plotting package\n\nd = 1.0 # water depth (m)\n‚Ñì = 10.0 # fluid domain length (m)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We define a number of numerical model parameters.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"‚Ñê = 40 # number of harmonics\nŒît = 0.01 # time step (s)\nt‚ÇÄ = 0.0 # initial time (s)\nœÑ = 2.0 # total simulation time (s)\nt = range(start = t‚ÇÄ, stop = œÑ, step = Œît) # time range\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We initialize a constant bottom wave problem p‚ÇÄ and an uneven bottom wave problem p‚ÇÅ using struct Problem. Please note that we set a bottom nonlinearity parameter M_b=40 in case of an uneven bottom, while for constant bottom we leave its default (M_b=0) value.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"p‚ÇÄ = Problem(‚Ñì, d, ‚Ñê, t)\np‚ÇÅ = Problem(‚Ñì, d, ‚Ñê, t; M_b=40)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"The free surface corresponds to a Gaussian surface_bump! of characteristic height h and length Œª and is applied to both problems p‚ÇÄ and p‚ÇÅ, while we add some bottom variation by applying a Gaussian bottom_bump! of characteristic height h‚ÇÅ and length Œª‚ÇÅ to problem p‚ÇÅ.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"h = 0.4d # surface bump height (m)\nŒª = 0.1‚Ñì # surface bump length (m)\nsurface_bump!(p‚ÇÄ, h, Œª)\nsurface_bump!(p‚ÇÅ, h, Œª)\nh‚ÇÅ = 0.9d # bottom bump height (m)\nŒª‚ÇÅ = 0.5‚Ñì # bottom bump length (m)\nbottom_bump!(p‚ÇÅ, h‚ÇÅ, Œª‚ÇÅ)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"We solve both problems. For that, we use an in-place function solve_problem!.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"solve_problem!(p‚ÇÄ; msg_flag=false)\nsolve_problem!(p‚ÇÅ; msg_flag=false)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Finally, we may calculate free surface elevation and bottom surface position using water_surface and bottom_surface functions","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Œ∑‚ÇÄ(x, n) = water_surface(p‚ÇÄ, x, n)\nŒ∑‚ÇÅ(x, n) = water_surface(p‚ÇÅ, x, n)\nŒ≤(x) = bottom_surface(p‚ÇÅ, x)\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"and plot the results for a range of spatial points x.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"x = range(start = - ‚Ñì / 2, stop = ‚Ñì / 2, length = 1001) # spatial range\no‚ÇÄ = Observable(Œ∑‚ÇÄ.(x, firstindex(t))) # set free-surface observable for p‚ÇÄ\no‚ÇÅ = Observable(Œ∑‚ÇÅ.(x, firstindex(t))) # set free-surface observable for p‚ÇÅ\ntitle = Observable(L\"t = %$(round(t[1], digits=1))\\,\\mathrm{s}\") # set string observable\nset_theme!(theme_latexfonts()) # set latex fonts\nfig = Figure(size = (700, 300)) # initialize a figure\n\n# left plot p‚ÇÄ\nax0 = Axis(fig[1, 1], \n        xlabel = L\"$x$ (m)\", \n        ylabel = L\"$z$ (m)\") # define axis with labels\nband!(ax0, x, o‚ÇÄ, -d, \n        color=:azure) # plot water bulk\nlines!(ax0, x, o‚ÇÄ, \n        color=:black, \n        linewidth = 1) # plot free surface line\nband!(ax0, x, -1.1d, - d, \n        color=:wheat) # plot bottom bulk\nhlines!(ax0, -d, \n        color=:black, \n        linewidth = 0.7) # plot bottom line\nlimits!(ax0, x[1], x[end], -1.1d, d) # set limits\n\n# right plot p‚ÇÅ\nax1 = Axis(fig[1, 2], \n        xlabel = L\"$x$ (m)\") # define axis with labels\nband!(ax1, x, o‚ÇÅ, Œ≤.(x) .-d, \n        color=:azure) # plot water bulk\nlines!(ax1, x, o‚ÇÅ, \n        color=:black, \n        linewidth = 1) # plot free surface line\nband!(ax1, x, Œ≤.(x) .- d, - 1.1d, \n        color=:wheat) # plot bottom bulk\nlines!(ax1, x, Œ≤.(x) .- d, \n        color=:black, \n        linewidth = 1) # plot bottom line\nlimits!(ax1, x[1], x[end], -1.1d, d) # set limits\nLabel(fig[0, :], text=title)\n\n# animate free surface\nrecord(fig, \"animation.mp4\", 1:lastindex(t);\n        framerate = 30) do n\n    o‚ÇÄ[] = Œ∑‚ÇÄ.(x, n)\n    o‚ÇÅ[] = Œ∑‚ÇÅ.(x, n)\n    title[] = L\"t = %$(round(t[n], digits=1))\\,\\mathrm{s}\"\nend\nnothing # hide","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../animation.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can define initial conditions, forcing mechanisms, bottom geometry and its kinematics, on your own following functions listed in the API. We are going to add more of them with subsequent updates of the package. Meanwhile go to the next section, where more examples are shown.","category":"page"},{"location":"api/#API","page":"API reference","title":"API","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#SpectralWaves.Problem","page":"API reference","title":"SpectralWaves.Problem","text":"Problem(‚Ñì::Real, d::Real, ‚Ñê::Integer, t::AbstractRange{Real}; O = 4, M_s = 0, M_b = 0, static_bottom = true)\n\nConstruct an IBV Problem object corresponding to a fluid domain of length ‚Ñì and depth d with ‚Ñê harmonics and N time steps.\n\nOutput is a Problem object with fields:\n\n‚Ñì is the fluid domain length (m),\nd is the water depth (m),\n‚Ñê is the number of harmonics,\nt is the time range,\nŒît is the time step (s),\nN is the number of time steps,\nO is the order of the time-stepping scheme,\nŒ∫ are wave numbers (rad/m),\nŒ∑ÃÇ are free-surface elevation amplitudes (m),\nŒ∑Ãá are free-surface vertical velocity amplitudes (m/s),\nŒ≤ÃÇ are bottom-surface elevation amplitudes (m),\nŒ≤Ãá are bottom-surface vertical velocity amplitudes (m/s),\nœïÃÇ are flat-bottom velocity potential amplitudes (m¬≤/s),\nœïÃá are flat-bottom acceleration potential amplitudes (m¬≤/s¬≤),\nœàÃÇ are uneven-bottom velocity potential amplitudes (m¬≤/s),\nœàÃá are uneven-bottom acceleration potential amplitudes (m¬≤/s¬≤),\npÃÇ are surface pressure head amplitudes (m),\nœá is wavemaker paddle displacement (m),\nŒæ is wavemaker paddle velocity (m/s),\nŒ∂ is wavemaker paddle acceleration (m/s¬≤),\nùíØ are hyperbolic tangent lookup values,\nùíÆ are hyperbolic secant lookup values,\nstatic_bottom is a boolean flag to indicate if the bottom is static.\n\n\n\n\n\n","category":"type"},{"location":"api/#SpectralWaves.absolute_error-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"API reference","title":"SpectralWaves.absolute_error","text":"absolute_error(a::Vector{<:Number}, b::Vector{<:Number})\n\nCompute absolute error between vectors a and b.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 1]; absolute_error(a, b)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.bottom_bump!","page":"API reference","title":"SpectralWaves.bottom_bump!","text":"bottom_bump!(p::Problem, h, Œª, x‚ÇÄ = 0)\n\nCalculate Œ≤ÃÇ coefficients of a problem p for a bottom bump of height h and characteristic length Œª at a position x‚ÇÄ.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectralWaves.bottom_slope!-Tuple{Problem, Any}","page":"API reference","title":"SpectralWaves.bottom_slope!","text":"bottom_slope!(p::Problem, h)\n\nCalculate Œ≤ÃÇ coefficients a wave problem p for a bottom slope of height h.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.bottom_step!-Tuple{Problem, Any}","page":"API reference","title":"SpectralWaves.bottom_step!","text":"bottom_step!(p::Problem, h)\n\nCalculate Œ≤ÃÇ coefficients of a wave problem p for a bottom step of height h.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.bottom_surface","page":"API reference","title":"SpectralWaves.bottom_surface","text":"bottom_surface(p::Problem, x::Real, n=1)\n\nCompute the bottom surface elevation Œ≤ at position x and for time instant n.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectralWaves.bottom_vector!-Tuple{Problem, AbstractRange{<:Real}, Vector{<:Real}}","page":"API reference","title":"SpectralWaves.bottom_vector!","text":"bottom_vector!(p::Problem, x::AbstractRange{<:Real}, Œ≤::Vector{<:Real})\n\nCalculate Œ≤ÃÇ coefficients of a wave problem p for a bottom profile Œ≤(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.convolution_power-Tuple{Vector{<:Number}, Integer}","page":"API reference","title":"SpectralWaves.convolution_power","text":"convolution_power(a::Vector{<:Number}, n::Integer)\n\nCompute convolution n-th power of vector a.\n\nExamples\n\njulia> a = [1, 2, 3]; convolution_power(a, 3)\n7-element Vector{Int64}:\n  1\n  6\n 21\n 44\n 63\n 54\n 27\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.convolution_range-Tuple{Integer, Integer, Integer}","page":"API reference","title":"SpectralWaves.convolution_range","text":"convolution_range(m::Integral, M::Integral, n::Integer)\n\nCompute range r of indices of a central part of convolution vector corresponding to the m-th order of convolution, where M is the maximum order of convolution, N is the length of convolution vector corresponding to the M-th order of convolution, and ‚Ñê is the number of harmonics.\n\nExamples\n\njulia> m = 1; M = 3; ‚Ñê = 5; c_range = convolution_range(m, M, ‚Ñê)\n11:31\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.convolve-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Vector{Ta}, Vector{Tb}}} where {Ta<:Number, Tb<:Number}","page":"API reference","title":"SpectralWaves.convolve","text":"convolve(a::Vector{Ta}, b::Vector{Tb}) where {Ta<:Number, Tb<:Number}\n\nCompute direct convolution of vectors a and b.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 1]; convolve(a, b)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.convolve_dsp-Union{Tuple{Tb}, Tuple{Ta}, Tuple{Vector{Ta}, Vector{Tb}}} where {Ta<:Number, Tb<:Number}","page":"API reference","title":"SpectralWaves.convolve_dsp","text":"convolve_dsp(a::Vector{Ta}, b::Vector{Tb}) where {Ta<:Number, Tb<:Number}\n\nCompute direct convolution of vectors a and b using DSP package.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 1]; convolve(a, b)\n3-element Vector{Int64}:\n 1\n 3\n 2\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.factorial_lookup-Tuple{Integer}","page":"API reference","title":"SpectralWaves.factorial_lookup","text":"factorial_lookup(n::Integer)\n\nCompute lookup table for factorials of numbers from 0 to n.\n\nExamples\n\njulia> factorial_lookup(3)\n4-element Vector{Float64}:\n  1.0\n  1.0\n  2.0\n  6.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.fourier_transform-Tuple{Vector{<:Real}, Real, AbstractRange{<:Real}}","page":"API reference","title":"SpectralWaves.fourier_transform","text":"fourier_transform(f::Vector{<:Number}, œâ::Real, x::AbstractRange{<:Real})\n\nCompute fÃÇ(œâ) using function values f at points x.\n\nExamples\n\njulia> f = [-1, 0, 1, 0, -1]; œâ = 1; x = range(-œÄ, œÄ, length = 5);\njulia> fourier_transform(f, œâ, x)\n0.5 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.general_error-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"API reference","title":"SpectralWaves.general_error","text":"general_error(a::Vector{<:Number}, b::Vector{<:Number})\n\nCompute a general error between vectors a and b as a relative_error(a, b) or an absolute_error(a, b) for norm(a) not equal or equal to 0, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.init_nonlinear_bottom_boundary_condition-NTuple{5, Any}","page":"API reference","title":"SpectralWaves.init_nonlinear_bottom_boundary_condition","text":"init_nonlinear_bottom_boundary_condition(Œ∫, ùíØ, ùíÆ, ‚Ñê, M)\n\nInitialize expansion coefficients for nonlinear bottom boundary conditions for eigenvalues Œ∫, hyperbolic tangent ùíØ and secant ùíÆ values, number of harmonics ‚Ñê and order of nonlinear expansion M.\n\nOutput is a tuple (Œ®ÃÇ‚Ä≤, Œ®ÃÇ‚Ä≥, Œ®ÃÉ‚Ä≤, Œ®ÃÉ‚Ä≥), where:\n\nŒ®ÃÇ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ®ÃÇ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing bottom velocity potential amplitudes and its vertical gradients,\nŒ®ÃÉ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ®ÃÉ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing bottom horizontal velocity potential amplitudes and its vertical gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.init_nonlinear_surface_boundary_condition-NTuple{5, Any}","page":"API reference","title":"SpectralWaves.init_nonlinear_surface_boundary_condition","text":"init_nonlinear_surface_boundary_condition(Œ∫, ùíØ, ùíÆ, ‚Ñê, M)\n\nInitialize expansion coefficients for nonlinear free-surface boundary conditions for eigenvalues Œ∫, hyperbolic tangent ùíØ and secant ùíÆ values, number of harmonics ‚Ñê and order of nonlinear expansion M.\n\nOutput is a tuple (Œ¶Ãá‚Ä≤, Œ¶Ãá‚Ä≥, Œ¶ÃÇ‚Ä≤, Œ¶ÃÇ‚Ä≥, Œ¶ÃÉ‚Ä≤, Œ¶ÃÉ‚Ä≥), where:\n\nŒ¶Ãá‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ¶Ãá‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing\n\nsurface acceleration potential amplitudes and its vertical gradients,\n\nŒ¶ÃÇ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ¶ÃÇ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing\n\nsurface velocity potential amplitudes and its vertical gradients,\n\nŒ¶ÃÉ‚Ä≤ are surface-potential-amplitude dependent expansion coefficients and\nŒ¶ÃÉ‚Ä≥ are bottom-potential-amplitude dependent expansion coefficients for computing\n\nsurface horizontal velocity potential amplitudes and its vertical gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.inverse_fourier_transform-Tuple{Vector{<:Number}, AbstractRange{<:Real}, Real}","page":"API reference","title":"SpectralWaves.inverse_fourier_transform","text":"inverse_fourier_transform(fÃÇ::Vector{<:Number}, œâ::AbstractRange{<:Real}, x::Real)\n\nCompute f(x) using expansion amplitudes fÃÇ and eigenvalues œâ.\n\nExamples\n\njulia> fÃÇ = [0.5, 0, 0.5]; œâ = -1:1; x = œÄ; inverse_fourier_transform(fÃÇ, œâ, x)\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.linear_regular_wave!-Tuple{Problem, Any, Any}","page":"API reference","title":"SpectralWaves.linear_regular_wave!","text":"linear_regular_wave!(p::Problem, H, L, nŒît)\n\nCalculate initial values of Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá for a regular linear wave of height H and length L.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.linear_wavemaker!-Tuple{Problem, Vararg{Any, 4}}","page":"API reference","title":"SpectralWaves.linear_wavemaker!","text":"linear_wavemaker!(p::Problem, H, L, t‚ÇÄ)\n\nCalculate wavemaker paddle displacement œá, velocity Œæ, and acceleration Œ∂ for a train of linear waves of height H and period T and a number of ramped periods nT‚ÇÄ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.moving_bottom_bump!","page":"API reference","title":"SpectralWaves.moving_bottom_bump!","text":"moving_bottom_bump!(p::Problem, h, Œª, u, x‚ÇÄ = 0)\n\nCalculate Œ≤ÃÇ coefficients of a wave problem p for a moving bottom bump of height h, characteristic length Œª, and velocity u at initial position x‚ÇÄ.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectralWaves.moving_pressure_bump!","page":"API reference","title":"SpectralWaves.moving_pressure_bump!","text":"moving_pressure_bump!(p::Problem, h, Œª, u, x‚ÇÄ = 0)\n\nCalculate pÃÇ coefficients of a problem p for a moving pressure bump of height h, characteristic length Œª, and velocity u at initial position x‚ÇÄ.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectralWaves.nonlinear_dfsbc_correction-NTuple{19, Any}","page":"API reference","title":"SpectralWaves.nonlinear_dfsbc_correction","text":"nonlinear_dfsbc_correction(Œ∑ÃÇ, œïÃÇ, œïÃá, œàÃÇ, œàÃá, Œ¶Ãá‚Ä≤, Œ¶Ãá‚Ä≥, Œ¶ÃÇ‚Ä≤, Œ¶ÃÇ‚Ä≥, Œ¶ÃÉ‚Ä≤, Œ¶ÃÉ‚Ä≥, Œ∫‚Ä≤, ‚Ñê, F, M, Œæ, Œ∂, ‚Ñì, d)\n\nCalculate nonlinear correction Œ¥œïÃá to dynamic free-surface boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.nonlinear_kfsbc_correction-NTuple{14, Any}","page":"API reference","title":"SpectralWaves.nonlinear_kfsbc_correction","text":"nonlinear_kfsbc_correction(Œ∑ÃÇ, œïÃÇ, œàÃÇ, Œ¶ÃÇ‚Ä≤, Œ¶ÃÇ‚Ä≥, Œ¶ÃÉ‚Ä≤, Œ¶ÃÉ‚Ä≥, Œ∫, Œ∫‚Ä≤, ‚Ñê, F, M)\n\nCalculate nonlinear correction Œ¥Œ∑Ãá to kinematic free-surface boundary condition.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.relative_error-Tuple{Vector{<:Number}, Vector{<:Number}}","page":"API reference","title":"SpectralWaves.relative_error","text":"relative_error(a::Vector{<:Number}, b::Vector{<:Number})\n\nCompute relative error between vectors a and b.\n\nExamples\n\njulia> a = [2, 2]; b = [1, 1]; relative_error(a, b)\n0.5\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.solve_problem!-Tuple{Problem}","page":"API reference","title":"SpectralWaves.solve_problem!","text":"solve_problem!(p::Problem; msg_flag = true)\n\nCalculate solution coefficients Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá, œàÃÇ, œàÃá of the wave problem.\n\nModified in-place variables:\n\nŒ∑ÃÇ are free-surface elevation potential amplitudes (m),\nŒ∑Ãá are free-surface vertical velocity amplitudes (m/s),\nœïÃÇ are flat-bottom velocity potential amplitudes (m¬≤/s),\nœïÃá are flat-bottom acceleration potential amplitudes (m¬≤/s¬≤),\nœàÃÇ are uneven-bottom velocity potential amplitudes (m¬≤/s),\nœàÃá are uneven-bottom acceleration potential amplitudes (m¬≤/s¬≤),\n\nInput variables:\n\nŒ≤ÃÇ are bottom-surface elevation amplitudes (m),\nŒ≤Ãá are bottom-surface vertical velocity amplitudes (m/s),\npÃÇ are surface pressure head amplitudes (m),\nŒ∫ are wave numbers (rad/m),\nùíØ are hyperbolic tangent lookup values,\nùíÆ are hyperbolic secant lookup values,\n‚Ñê is the number of harmonics,\nM_s is the order of nonlinear free-surface boundary condition,\nM_b is the order of nonlinear bottom boundary condition,\nŒît is the time step (s),\nO is the order of the time-stepping scheme,\nN is the number of time steps,\nœá is wavemaker paddle displacement (m),\nŒæ is wavemaker paddle velocity (m/s),\nŒ∂ is wavemaker paddle acceleration (m/s¬≤),\n‚Ñì is the fluid domain length (m),\nd is the water depth (m).\n\nKeyword arguments:\n\nstatic_bottom is a boolean flag to indicate whether the bottom is static,\nmsg_flag is a boolean flag to indicate whether to print progress messages.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.surface_bump!","page":"API reference","title":"SpectralWaves.surface_bump!","text":"surface_bump!(p::Problem, h, Œª, x‚ÇÄ = 0)\n\nCalculate Œ∑ÃÇ coefficients of a problem p for a surface bump of height h and characteristic length Œª at position x‚ÇÄ.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectralWaves.surface_pressure","page":"API reference","title":"SpectralWaves.surface_pressure","text":"surface_pressure(p::Problem, x::Real, n=1)\n\nCompute the surface pressure P at position x and for time instant n.\n\n\n\n\n\n","category":"function"},{"location":"api/#SpectralWaves.time_integration_coeffs-Tuple{Integer}","page":"API reference","title":"SpectralWaves.time_integration_coeffs","text":"time_integration_coeffs(O::Integer)\n\nCalculate Adams-Bashforth-Moulton time-stepping scheme coefficients for a given order O.\n\nOutput is a tuple of two vectors with Adams-Bashforth and Adams-Moulton coefficients, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.toeplitz-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"API reference","title":"SpectralWaves.toeplitz","text":"toeplitz(a::Vector{T}) where T\n\nTransform vector a to a Toeplitz matrix.\n\nExamples\n\njulia> a = [1, 2, 3]; toeplitz(a)\n2√ó2 Matrix{Int64}:\n 2  1\n 3  2\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.update_bbc_sle!-NTuple{14, Any}","page":"API reference","title":"SpectralWaves.update_bbc_sle!","text":"update_bbc_sle!(A‚Ä≤, A‚Ä≥, Œ®ÃÇ‚Ä≤, Œ®ÃÇ‚Ä≥, Œ®ÃÉ‚Ä≤, Œ®ÃÉ‚Ä≥, w‚Ä≤, Œ≤ÃÇ, Œ∫, Œ∫‚Ä≤, ‚Ñê, F, M)\n\nCompute coefficients A‚Ä≤, A‚Ä≥, and w‚Ä≤ for the bottom boundary condition system of linear equations (SLE).\n\nModified in-place variables:\n\nA‚Ä≤ are constant coefficients of the system of linear equations and\nA‚Ä≥ are coefficients of the system of linear equations,\nw‚Ä≤ are coefficients corresponding to the linear wavemaker term.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.water_surface-Tuple{Problem, Real, Integer}","page":"API reference","title":"SpectralWaves.water_surface","text":"water_surface(p::Problem, x::Real, n::Integer)\n\nCompute the water surface elevation Œ∑ at position x and for time instant n.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpectralWaves.water_velocity-Tuple{Problem, Real, Real, Integer, Symbol}","page":"API reference","title":"SpectralWaves.water_velocity","text":"water_velocity(p::Problem, x::Real, z::Real, n::Integer, c::Symbol)\n\nCompute the water velocity component u or w using the symbol :x or :z at position (x, z), and for time instant n.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Regular-linear-waves","page":"Examples","title":"Regular linear waves","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We are modelling linear and regular waves of length L and height H propagating in water of constant depth d. We consider one wave along the length of the domain ‚Ñì. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SpectralWaves\nusing CairoMakie # plotting package\n\nL = 2.0 # wavelength (m)\nH = 0.1 # wave height (m)\nd = 1.0 # water depth (m)\n‚Ñì = L # fluid domain length (m) - one wave\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We need a wave period T.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"k = 2œÄ / L # wave number (rad/m)\nœâ = sqrt(g * k * tanh(k * d)) # angular wave frequency (rad/s)\nT = 2œÄ / œâ # wave period (s)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We define a number of numerical model parameters.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"‚Ñê = 1 # number of harmonics\nnŒît = 200 # number of time increments per wave period\nŒît = T / nŒît # time step (s)\nnT = 1 # number of periods\nt‚ÇÄ = 0.0 # initial time (s)\nœÑ = nT * T # total simulation time (s)\nt = range(start = t‚ÇÄ, stop = œÑ, step = Œît) # time range\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We initialize wave problem using a struct Problem.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p = Problem(‚Ñì, d, ‚Ñê, t)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Initial condition values of hateta, doteta, hatphi, and dotphi are computed and inserted into vectors Œ∑ÃÇ, Œ∑Ãá, œïÃÇ, œïÃá using linear_regular_wave! in-place function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"linear_regular_wave!(p, H, œâ)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we are ready to solve a problem.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"solve_problem!(p; msg_flag=false)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We define a function that calculates free-surface elevation at specified location x and time instant n and velocity components u and w at specified location (x, z) and time instant n using water_surface, water_velocity functions. Please note that the last argument to water_velocity specifies the axis of projection of the velocity vector using symbolic variables :x or  :z.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Œ∑(x, n) = water_surface(p, x, n)\nu(x, z, n) = (z < Œ∑(x, n)) * water_velocity(p, x, z, n, :x)\nw(x, z, n) = (z < Œ∑(x, n)) * water_velocity(p, x, z, n, :z)\nv(x, z, n) = sqrt.(u(x, z, n)^2 + w(x, z, n)^2)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We need a grid to present results.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"x = range(start = 0, stop = ‚Ñì, length = 21)\nz = range(start = -d, stop = H, length = 11)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally we are ready to plot results.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"n = 101\nset_theme!(theme_latexfonts()) # set latex fonts\nfig = Figure(size = (700, 300)) \nax = Axis(fig[1, 1], xlabel = L\"$x$ (m)\", ylabel = L\"$\\eta$ (m)\")\nband!(ax, x, Œ∑.(x, n), -d, \n        color=:azure) # plot water bulk\nlines!(ax, x, Œ∑.(x, n), \n        color=:black, \n        linewidth = 1) # plot free surface\nband!(ax, x, -1.1d, - d, \n        color=:wheat) # plot bottom bulk\nhlines!(ax, -d, \n        color=:black, \n        linewidth = 0.7) # plot bottom line\narrows!(ax, x, z, u.(x, z', n), w.(x, z', n); \n    lengthscale = 0.3,\n    arrowsize = 10 * vec(v.(x, z', n)/maximum(v.(x, z', n)))) # plot velocity vectors\nlimits!(ax, 0, L, -1.1d, H)\nfig","category":"page"},{"location":"examples/#Linear-shoaling","page":"Examples","title":"Linear shoaling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We are modelling linear and regular waves of length L and height H climbing up a slope. We apply a linear wavemaker at both sides of the domain, while we consider only a half of the domain of length ‚Ñì.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SpectralWaves\nusing CairoMakie # plotting package\n\nL = 5.0 # wavelength (m)\nH = 0.05 # wave height (m)\nd = 1.0 # water depth (m)\n‚Ñì = 200.0 # fluid domain length (m)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Again, we need a wave period T.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"k = 2œÄ / L # wave number (rad/m)\nœâ = sqrt(g * k * tanh(k * d)) # angular wave frequency (rad/s)\nT = 2œÄ / œâ # wave period (s)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We define a number of numerical model parameters. In order to secure a smooth start of the wavemaker paddle, we define a number of ramped wave periods nT‚ÇÄ in addition to a total number of simulated wave periods nT.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"‚Ñê = 600 # number of harmonics\nnT = 30 # number of simulated wave periods\nnT‚ÇÄ = 3 # number of ramped wave periods\nnŒît = 200 # number of time steps per wave period\nŒît = T / nŒît # time step (s)\nt‚ÇÄ = 0.0 # initial time (s)\nœÑ = nT * T # total simulation time (s)\nt = range(start = t‚ÇÄ, stop = œÑ, step = Œît) # time range\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We initialize wave problem p with M_b=40.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p = Problem(‚Ñì, d, ‚Ñê, t; M_b=40)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use linear_wavemaker! function to define wavemaker paddle motion.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"linear_wavemaker!(p, H, T, L, nT‚ÇÄ)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The slope of height h is introduced using bottom_slope! function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"h = 0.9d\nbottom_slope!(p, h)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And we solve the problem.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"solve_problem!(p; msg_flag=false)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We calculate free surface elevation and bottom surface position using water_surface and bottom_surface functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Œ∑(x, n) = water_surface(p, x, n)\nŒ≤(x) = bottom_surface(p, x)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and we are ready to animate results and see how the waves shoal.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"x = range(start = 0, stop = ‚Ñì / 3, length = 501) # spatial range\nŒ∑‚ÇÄ = Observable(Œ∑.(x, firstindex(t))) # set free-surface observable for p\nset_theme!(theme_latexfonts()) # set latex fonts\nfig = Figure(size = (700, 300)) # initialize a figure\nax = Axis(fig[1, 1], \n        xlabel = L\"$x$ (m)\", \n        ylabel = L\"$z$ (m)\") # define axis with labels and title\nband!(ax, x, Œ∑‚ÇÄ, Œ≤.(x) .-d, \n        color=:azure) # plot water bulk\nlines!(ax, x, Œ∑‚ÇÄ, \n        color=:black, \n        linewidth = 1) # plot free surface line\nband!(ax, x, Œ≤.(x) .- d, - 1.1d, \n        color=:wheat) # plot bottom bulk\nlines!(ax, x, Œ≤.(x) .- d, \n        color=:black, \n        linewidth = 1) # plot bottom line\nlimits!(ax, x[1], x[end], -1.1d, 2H) # set limits\n\n# animate free surface\nrecord(fig, \"shoaling.mp4\", lastindex(t)-nŒît+1:lastindex(t);\n        framerate = nŒît) do n\n    Œ∑‚ÇÄ[] = Œ∑.(x, n)\nend\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../shoaling.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Replacing p = Problem(‚Ñì, d, ‚Ñê, t; M_b=40) with p = Problem(‚Ñì, d, ‚Ñê, t; M_b=40, M_s=2) gives a corresponding nonlinear shoaling, which looks like this:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../nonlinear_shoaling.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/#Linear-wave-transformation-at-a-step","page":"Examples","title":"Linear wave transformation at a step","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We are modelling linear and regular waves of length L and height H undergoing a transformation at an underwater step. We apply a linear wavemaker at both sides of the domain, while we consider only a half of the domain of length ‚Ñì.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SpectralWaves\nusing CairoMakie # plotting package\n\nL = 10.0 # wavelength (m)\nH = 0.05 # wave height (m)\nd = 1.0 # water depth (m)\n‚Ñì = 200.0 # fluid domain length (m)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We need a wave period T.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"k = 2œÄ / L # wave number (rad/m)\nœâ = sqrt(g * k * tanh(k * d)) # angular wave frequency (rad/s)\nT = 2œÄ / œâ # wave period (s)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We define a number of numerical model parameters (cf. linear shoaling example).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"‚Ñê = 400 # number of harmonics\nnT = 16 # number of simulated wave periods\nnT‚ÇÄ = 3 # number of ramped wave periods\nnŒît = 200 # number of time steps per wave period\nŒît = T / nŒît # time step (s)\nt‚ÇÄ = 0.0 # initial time (s)\nœÑ = nT * T # total simulation time (s)\nt = range(start = t‚ÇÄ, stop = œÑ, step = Œît) # time range\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We initialize wave problem p with M_b=40.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p = Problem(‚Ñì, d, ‚Ñê, t; M_b=40)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use linear_wavemaker! function to define wavemaker paddle motion.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"linear_wavemaker!(p, H, T, L, nT‚ÇÄ)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The step of height h is introduced using bottom_step! function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"h = 0.6d\nbottom_step!(p, h)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We solve the problem.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"solve_problem!(p; msg_flag=false)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We calculate free surface elevation and bottom surface position using water_surface and bottom_surface functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Œ∑(x, n) = water_surface(p, x, n)\nŒ≤(x) = bottom_surface(p, x)\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and we animate the results to see how the waves undergo transformation at a step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"x = range(start = ‚Ñì / 8, stop = 3‚Ñì / 8, length = 501) # spatial range\nŒ∑‚ÇÄ = Observable(Œ∑.(x, firstindex(t))) # set free-surface observable for p\nset_theme!(theme_latexfonts()) # set latex fonts\nfig = Figure(size = (700, 300)) # initialize a figure\nax = Axis(fig[1, 1], \n        xlabel = L\"$x$ (m)\", \n        ylabel = L\"$z$ (m)\") # define axis with labels and title\nband!(ax, x, Œ∑‚ÇÄ, Œ≤.(x) .-d, \n        color=:azure) # plot water bulk\nlines!(ax, x, Œ∑‚ÇÄ, \n        color=:black, \n        linewidth = 1) # plot free surface line\nband!(ax, x, Œ≤.(x) .- d, - 1.1d, \n        color=:wheat) # plot bottom bulk\nlines!(ax, x, Œ≤.(x) .- d, \n        color=:black, \n        linewidth = 1) # plot bottom line\nlimits!(ax, x[1], x[end], -1.1d, 2H) # set limits\n\n# animate free surface\nrecord(fig, \"step_transformation.mp4\", lastindex(t)-nŒît+1:lastindex(t);\n        framerate = nŒît) do n\n    Œ∑‚ÇÄ[] = Œ∑.(x, n)\nend\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../step_transformation.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Again, we may compute nonlinear scenario using p = Problem(‚Ñì, d, ‚Ñê, t; M_b=40, M_s=2).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../nonlinear_step_transformation.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"#SpectralWaves.jl","page":"Home","title":"SpectralWaves.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Fourier Galerkin method solution to nonlinear waves propagating over topography.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpectralWaves.jl is a Julia package for simulation of nonlinear waves propagating over arbitrary topography under potential flow assumptions. The solution is derived using a Fourier Galerkin spectral method in terms of amplitudes of free-surface elevation and velocity potential, while inverse Fourier transform is used to get a phase-resolved wave field. Four wave generation mechanisms are supported - initial conditions, linear wavemaker forcing, pressure forcing (to be implemented), moving bottom. ","category":"page"},{"location":"#Wave-problem","page":"Home","title":"Wave problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We consider waves propagating over arbitrary bottom topography in a periodic fluid domain of length ell and characteristic depth d (corresponding to still water level). A Cartesian coordinate system is used to define fluid elements along horizontal x-axis coinciding with undisturbed free surface and upward-pointing and vertical z-axis. Undulating free surface is described by means of eta(x t), while bottom topography is considered as fluctuations beta(x t) around -d. The general scheme is presented in figure 1 below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"../../examples/docs_figure_1.jl\") # hide\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Figure 1: Propagation of waves over topography in a periodic fluid domain.","category":"page"},{"location":"","page":"Home","title":"Home","text":"According to potential flow assumptions (irrotational flow of an inviscid and incompressible fluid), we define velocity vector field mathbfv(x z t) = nablaPhi(x z t) and formulate a our boundary-value problem in a following way (table 1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Table 1: Initial boundary-value problem of waves propagating over topography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equation Region Description\nfracpartial^2Phipartial x^2 + fracpartial^2Phipartial z^2 = 0 -d + beta leq z leq eta Laplace's equation\nfracpartialetapartial t + fracpartialetapartial xfracpartialPhipartial x - fracpartialPhipartial z = 0 z = eta Kinematic free-surface boundary condition\nfracpartialPhipartial t + geta + frac12left(u^2 + w^2 right) = 0 z = eta Dynamic free-surface boundary condition\nfracpartialbetapartial t + fracpartialbetapartial xfracpartialPhipartial x - fracpartialPhipartial z = 0 z = beta - d Kinematic bottom boundary condition\nPhi(x + ell z t) = Phi(x z t) x = 0 ell Periodic lateral boundary condition","category":"page"},{"location":"","page":"Home","title":"Home","text":"where u = partialPhi  partial x and w  = partialPhi  partial z are horizontal and vertical velocity components, respectively, while a gravitational acceleration gapprox 981mathrmms^2. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below, we provide a description of the spectral solution to the problem of waves propagating over topography. Anxious users may skip this part and go directly to our guide.","category":"page"},{"location":"#Spectral-solution","page":"Home","title":"Spectral solution","text":"","category":"section"},{"location":"#Fourier-series-expansions","page":"Home","title":"Fourier series expansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We use spectral expansions of Phi, eta, and beta, while additionally Phi is decomposed into parts: phi - satisfying homogeneous problem of waves propagating over horizontal bottom and psi - satisfying a corrugated bottom correction. The total velocity potential Phi satisfies Laplace equation. In Table 2, we provide spectral expansion formulas of Phi, phi, psi, eta, and beta along with velocity components u and w.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Table 2: Spectral expansion formulas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equation Description\nPhi(x z t) = phi(x z t) + psi(x z t) Total velocity potential\nphi(x z t) = sum_i=-I^I hatphi_i(t)fraccoshkappa_i(z+d)coshkappa_idmathrme^mathrmikappa_ix Flat-bottom velocity potential\npsi(xzt) = hatpsi_0(t)z + sum_i=-Iwedgeine0^Ihatpsi_i(t)fracsinhkappa_izkappa_icoshkappa_idmathrme^mathrmikappa_ix Corrugated bottom velocity potential\neta(x t) = sum_i=-I^Ihateta_i(t)mathrme^mathrmikappa_ix Free-surface elevation\nbeta(x t) = sum_i=-I^Ihatbeta_i(t)mathrme^mathrmikappa_ix Bottom topography\nu(x z t) = sum_i=-Iwedgeine0^Imathrmifrachatphi_i(t)kappa_icoshkappa_i(z+d) + hatpsi_i(t)sinhkappa_izcoshkappa_idmathrme^mathrmikappa_ix Horizontal velocity component\nw(x z t) = hatpsi_0(t)+ sum_i=-Iwedgeine0^Ifrachatphi_i(t)kappa_isinhkappa_i(z+d) + hatpsi_i(t)coshkappa_izcoshkappa_idmathrme^mathrmikappa_ix Vertical velocity component","category":"page"},{"location":"","page":"Home","title":"Home","text":"where kappa_i=i2piell are solution eigenvalues corresponding to I individual wave harmonics; the primed sum refers to omitting non-oscillatory eigenvalue kappa_0=0. mathrmi^2=-1, while the hat accent hat denotes solution amplitudes. We also use tilde tilde and dot dot accents to highlight amplitudes corresponding to time and horizontal gradients.","category":"page"},{"location":"#Taylor-series-expansions","page":"Home","title":"Taylor series expansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The solution to the wave problem is achieved by introducing Fourier series expansions presented in table 2 to Taylor series expansions of boundary conditions presented in table 1. As a result, we get two evolution equations of free-surface elevation and velocity potential (from the kinematic and dynamic free-surface boundary conditions) and a set of linear equations (SLE) relating velocity potential coefficients of a homogeneous flat-bottom and corrugated problem (from the bottom boundary condition). In table 3, we provide implementation-ready forms of the solution equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Table 3: Implementation-ready forms of the solution equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Equation Description\ndoteta_i = kappa_ihatphi_imathcalT_i + hatpsi_imathcalS - deltadoteta_i Evolution equation for free-surface elevation\ndotphi_i = -ghateta_i - deltadotphi_i Evolution equation for velocity potential\nleft(mathbfI-sum_m=0^M_psi-1left(mathbftildeB_modotleft(mathbftildePsi_m^primeotimesmathbf1right)-mathbfhatB_modotleft(mathbfhatPsi_m+1^primeotimesmathbf1right)right)right)cdotmathbfhatpsi=mathbfdotbeta + sum_m=0^M_psi-1left(mathbftildeB_modotleft(mathbftildePsi_m^primeprimeotimesmathbf1right)-mathbfhatB_modotleft(mathbfhatPsi_m+1^primeprimeotimesmathbf1right)right)cdotmathbfhatphi System of linear equations relating bottom and flat-bed velocity potential coefficients","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":" \nmathcalT_i = tanhkappa_id\nmathcalS_i = mathrmsechkappa_id\ndeltadoteta_i = sum_m=0^M_phi-1left(fracmathbfhateta^*mm*left(mathbftildeeta*mathbftildePhi_m-frac1m+1mathbfhateta*mathbfhatPhi_m+1right)right)_i\ndeltadotphi_i = sum_m=0^M_phi-1left(fracmathbfhateta^*mm*left(frac1m+1mathbfhateta*mathbfdotPhi_m+1+frac12sum_n=0^mbinommnleft(mathbftildePhi_n*mathbftildePhi_m-n+mathbfhatPhi_n*mathbfhatPhi_m-nright)right)right)_i\ntildeeta_i = mathrmikappa_ihateta\ndotPhi_im = kappa_i^mdotphi_i(2mid m) + (kappa_i^mdotphi_imathcalT_i + kappa_i^m-1dotpsi_imathcalS_i)(2nmid m)\nhatPhi_im = (kappa_i^m+1hatphi_imathcalT_i + kappa_i^mhatpsi_imathcalS_i)(2mid m) + kappa_i^m+1hatphi_i(2nmid m)\ntildePhi_im = mathrmikappa_i^m+1hatphi_i(2mid m) + mathrmi(kappa_i^m+1hatphi_imathcalT_i + kappa_i^mhatpsi_imathcalS_i)(2nmid m)\nhatPsi_i = kappa_i^mhatpsi_i(2mid m) + (kappa_i^m+1hatphi_imathcalS_i - kappa_i^mhatpsi_imathcalT_i)(2nmid m)\ntildePsi_i = mathrmi(kappa_i^m+1hatphi_imathcalS_i - kappa_i^mhatpsi_imathcalT_i)(2mid m) + mathrmikappa_i^mhatpsi_i(2nmid m)\nmathbftildeB_ijm = left(fracmathbfhatbeta^*m*mathbftildebetamright)_i-j\nmathbfhatB_ijm = left(fracmathbfhatbeta^*(m+1)(m+1)right)_i-j\nhatPsi_im^prime = kappa_i^m(2mid m) - kappa_i^mmathcalT_i(2nmid m)\nhatPsi_im^primeprime = kappa_i^m+1mathcalS_i(2nmid m)\ntildePsi_im^prime = - mathrmikappa_i^mmathcalT_i(2mid m) + mathrmikappa_i^m(2nmid m)\ntildePsi_im^prime = mathrmikappa_i^m+1mathcalS_i(2mid m)","category":"page"},{"location":"#Numerics","page":"Home","title":"Numerics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provided that initial conditions with respect to mathbfhatphi, mathbfdotphi, mathbfhatpsi, mathbfdotpsi, mathbfhateta, mathbfdoteta are known and the bottom and its evolution is prescribed in terms of mathbfhatbeta and mathbfdotbeta, respectively, we apply time-stepping procedure to get the solution. It is based on iterative application of evolution equations and solving the system of linear equations at each time step until a desired accuracy is reached. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An Adams-Bashforth-Moulton time-stepping method is chosen and is used according to Last Point Approximation scheme, where the predictor is applied to the velocity potential amplitudes and the corrector to the free-surface elevation amplitudes. Below the simplest formulas of mathcalO(1) are provided","category":"page"},{"location":"","page":"Home","title":"Home","text":" \nhatphi_i(t+Delta t) = hatphi_i(t) + Delta tdotphi_i(t) AB predictor mathcalO(1)\nhateta_i(t+Delta t) = hateta_i(t) + Delta tdoteta_i(t + Delta t) AM corrector mathcalO(1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In between predictor and corrector evaluations and at each iteration, a system of linear equations matching hatphi_i and hatpsi_i coefficients is solved. In case of static bottom topography, an initial factorization of SLE coefficients matrix is employed for efficiency.","category":"page"}]
}
